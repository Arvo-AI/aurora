# ==============================================================================
# Aurora Helm Chart - Default Configuration
# ==============================================================================
# This file contains all available configuration options with sensible defaults.
# Copy this file to `values.generated.yaml` and customize for your deployment.
#
# DO NOT commit values.generated.yaml - it contains secrets!
# ==============================================================================

# ------------------------------------------------------------------------------
# Chart metadata (optional overrides)
# ------------------------------------------------------------------------------
nameOverride: ""
fullnameOverride: ""

# ------------------------------------------------------------------------------
# Container images
# ------------------------------------------------------------------------------
image:
  # Container registry where images are stored
  registry: "your-registry"  #Examples: docker.io/myorg, gcr.io/project-id, ghcr.io/myorg
  
  # Image tag (version) to deploy
  tag: "latest"
  
  # Optional: Pull secrets for private registries
  # pullSecrets:
  #   - name: regcred

# ------------------------------------------------------------------------------
# Replica counts per service
# ------------------------------------------------------------------------------
replicaCounts:
  server: 1          # API server (Flask)
  celeryWorker: 2    # Background task workers
  celeryBeat: 1      # Task scheduler (only 1 needed)
  chatbot: 1         # WebSocket chatbot server
  frontend: 1        # Next.js frontend
  redis: 1           # Redis cache (single instance)
  searxng: 1         # Web search engine
  weaviate: 1        # Vector database
  transformers: 1    # ML model service
  vault: 1           # Secrets manager (StatefulSet)
  postgres: 1        # Database (StatefulSet)

# ------------------------------------------------------------------------------
# Application configuration (non-sensitive)
# ------------------------------------------------------------------------------
config:
  AURORA_ENV: "production" # Environment: dev, staging, production
  
  # --- Database ---
  POSTGRES_HOST: ""  # Auto-generated if empty: <release>-postgres
  POSTGRES_PORT: "5432"
  POSTGRES_DB: "aurora_db"
  
  # --- Redis Cache ---
  REDIS_URL: ""  # Auto-generated if empty: redis://<release>-redis:6379/0
  
  # --- S3-Compatible Object Storage (REQUIRED) ---
  # Supports: AWS S3, MinIO, Cloudflare R2, Backblaze B2, etc.
  STORAGE_BUCKET: ""             # REQUIRED - Your bucket name
  STORAGE_ENDPOINT_URL: ""       # REQUIRED - e.g., https://s3.amazonaws.com
  STORAGE_REGION: "us-east-1"    # Your storage region
  STORAGE_USE_SSL: "true"
  STORAGE_VERIFY_SSL: "true"
  STORAGE_CACHE_ENABLED: "true"
  STORAGE_CACHE_TTL: "60"
  
  # --- Vector Database (Weaviate) ---
  WEAVIATE_HOST: ""  # Auto-generated if empty: <release>-weaviate
  WEAVIATE_PORT: "8080"
  WEAVIATE_GRPC_PORT: "50051"
  
  # --- Public URLs (REQUIRED) ---
  # These are exposed to the frontend and must match your domain/ingress
  # Uses subdomain-based routing (industry standard for APIs)
  NEXT_PUBLIC_BACKEND_URL: "" #Example: https://api.aurora.example.com
  NEXT_PUBLIC_WEBSOCKET_URL: "" #Example: wss://ws.aurora.example.com
  FRONTEND_URL: "" #Example: https://aurora.example.com
  
  # --- Internal Service URLs ---
  BACKEND_URL: ""             # Auto-generated if empty: http://<release>-server:5080
  CHATBOT_INTERNAL_URL: ""    # Auto-generated if empty: http://<release>-chatbot:5007
  VAULT_ADDR: ""              # Default applied by chart when empty: http://<release>-vault:8200
  SEARXNG_URL: ""             # Auto-generated if empty: http://<release>-searxng:8080
  SEARXNG_BASE_URL: ""        #Example: https://aurora.example.com
  
  # --- Flask/API Configuration ---
  FLASK_PORT: "5080"
  VAULT_KV_MOUNT: "aurora"
  VAULT_KV_BASE_PATH: "users"
  
  # --- LLM Configuration ---
  LLM_PROVIDER_MODE: "openrouter"  #Provider: openrouter, openai, anthropic, google
  AGENT_RECURSION_LIMIT: "240" #Maximum number of steps an agent can take
  
  # --- Performance & Caching ---
  AURORA_SETUP_CACHE_ENABLED: "true"
  AURORA_SETUP_CACHE_TTL: "3600"
  AURORA_CACHE_TOKEN_IN_REDIS: "false"
  RCA_OPTIMIZE_COSTS: "false"
  GEMINI_DISABLE_THINKING: "false"
  
  # --- Security ---
  RATE_LIMITING_ENABLED: "false"
  RATE_LIMIT_HEADERS_ENABLED: "true"
  AURORA_VERIFY_CLI_IDENTITY: "false"
  
  # --- Optional Features (enable as needed) ---
  ENABLE_POD_ISOLATION: "false"              # Isolate conversations in separate pods should be true for production
  NEXT_PUBLIC_ENABLE_OVH: "false"            # OVH Cloud integration
  NEXT_PUBLIC_ENABLE_SLACK: "false"          # Slack notifications
  NEXT_PUBLIC_ENABLE_PAGERDUTY_OAUTH: "false" # PagerDuty integration
  NEXT_PUBLIC_ENABLE_CONFLUENCE: "false"     # Confluence integration
  
  # --- Pod Isolation Settings (if enabled) ---
  TERMINAL_NAMESPACE: "untrusted"
  TERMINAL_IMAGE: ""
  TERMINAL_POD_TTL: "3600"
  TERMINAL_RUNTIME_CLASS: ""  # Kubernetes RuntimeClass for terminal pods. Leave empty for default runtime. Examples: "gvisor" (sandboxing), "kata" (VM isolation)
  CHATBOT_POD_TTL: "600"
  USE_UNTRUSTED_NODES: "true"
  
  # --- Kubectl Agent (optional) ---
  NEXT_PUBLIC_KUBECTL_AGENT_CHART_URL: ""
  
  # --- Development (optional) ---
  NGROK_URL: ""

# ------------------------------------------------------------------------------
# Secrets (REQUIRED - must be set in values.generated.yaml)
# ------------------------------------------------------------------------------
secrets:
  # --- Database Credentials (secret-db.yaml) ---
  db: # Mounted by: server, celery-worker, celery-beat, chatbot, postgres
    POSTGRES_USER: "aurora"
    POSTGRES_PASSWORD: ""        # REQUIRED - Generate with: openssl rand -base64 32
  
  # --- Backend Secrets (secret-backend.yaml) ---
  backend:  # Mounted by: server, celery-worker, celery-beat, chatbot
    VAULT_TOKEN: ""              # REQUIRED - Root token from Vault init - Set after running: kubectl exec -it statefulset/<release>-vault -- vault operator init
    STORAGE_ACCESS_KEY: ""       # REQUIRED - Your S3 access key
    STORAGE_SECRET_KEY: ""       # REQUIRED - Your S3 secret key
  
  # --- Application Secrets (secret-app.yaml) ---
  app:   # Mounted by: server, celery-worker, celery-beat, chatbot, frontend, searxng
    FLASK_SECRET_KEY: ""         # REQUIRED - Generate with: openssl rand -base64 32
    AUTH_SECRET: ""              # REQUIRED - Generate with: openssl rand -base64 32
    SEARXNG_SECRET: ""           # REQUIRED - Generate with: openssl rand -base64 32
    
    # --- Optional: Slack Integration ---
    SLACK_CLIENT_ID: ""          # Get from: https://api.slack.com/apps
    SLACK_CLIENT_SECRET: ""
    SLACK_SIGNING_SECRET: ""
    
    # --- Optional: GitHub OAuth ---
    GH_OAUTH_CLIENT_ID: ""       # Get from: https://github.com/settings/developers
    GH_OAUTH_CLIENT_SECRET: ""
    
    # --- Optional: PagerDuty Integration ---
    PAGERDUTY_CLIENT_ID: ""
    PAGERDUTY_CLIENT_SECRET: ""
    
    # --- Optional: GCP OAuth (for GCP integrations) ---
    CLIENT_ID: ""                # GCP OAuth client ID
    CLIENT_SECRET: ""            # GCP OAuth client secret
    
    # --- Optional: OVH Cloud Integration ---
    OVH_EU_CLIENT_ID: ""         # Europe region
    OVH_EU_CLIENT_SECRET: ""
    OVH_CA_CLIENT_ID: ""         # Canada region
    OVH_CA_CLIENT_SECRET: ""
    OVH_US_CLIENT_ID: ""         # US region
    OVH_US_CLIENT_SECRET: ""
    
    # --- Optional: AWS Integration ---
    AWS_ACCESS_KEY_ID: ""
    AWS_SECRET_ACCESS_KEY: ""
    
    # --- Optional: Email/SMTP ---
    SMTP_HOST: ""                # e.g., smtp.gmail.com
    SMTP_PORT: "587"
    SMTP_USER: ""
    SMTP_PASSWORD: ""
    SMTP_FROM_EMAIL: ""
    SMTP_FROM_NAME: "Aurora"
    
    # --- Optional: Rate Limiting Bypass ---
    RATE_LIMIT_BYPASS_TOKEN: ""  # Custom token to bypass rate limits
  
  # --- LLM API Keys (secret-llm.yaml) ---
  llm:  # Mounted by: chatbot, celery-worker, celery-beat
    # At least one LLM API key is required
    OPENROUTER_API_KEY: ""       # Get from: https://openrouter.ai/keys
    OPENAI_API_KEY: ""           # Get from: https://platform.openai.com/api-keys
    ANTHROPIC_API_KEY: ""        # Get from: https://console.anthropic.com/
    GOOGLE_AI_API_KEY: ""        # Get from: https://makersuite.google.com/app/apikey
    
    # --- Optional: Web Search ---
    TAVILY_API_KEY: ""           # Get from: https://tavily.com/

# ------------------------------------------------------------------------------
# Resource requests and limits
# ------------------------------------------------------------------------------
# Adjust based on your cluster capacity and workload
resources:
  server:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"
  
  celeryWorker:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"
  
  celeryBeat:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "1Gi"
  
  chatbot:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"
  
  frontend:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "1Gi"
  
  redis:
    requests:
      cpu: "50m"
      memory: "128Mi"
    limits:
      cpu: "250m"
      memory: "256Mi"
  
  searxng:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "512Mi"
  
  weaviate:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"
  
  transformers:
    requests:
      cpu: "200m"
      memory: "1Gi"
    limits:
      cpu: "1500m"
      memory: "3Gi"
  
  vault:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "1Gi"
  
  postgres:
    requests:
      cpu: "200m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "2Gi"

# ------------------------------------------------------------------------------
# Persistent storage
# ------------------------------------------------------------------------------
persistence:
  postgres:
    size: 50Gi           # Database storage
  weaviate:
    size: 50Gi           # Vector embeddings storage
  vault:
    size: 10Gi           # Secrets storage

# ------------------------------------------------------------------------------
# Ingress configuration
# ------------------------------------------------------------------------------
# Uses subdomain-based routing (industry standard):
#   aurora.example.com     → Frontend
#   api.aurora.example.com → API Server
#   ws.aurora.example.com  → WebSocket Server
ingress:
  enabled: true
  className: "nginx"   # Use your ingress controller class
  
  # TLS/HTTPS Configuration
  # ------------------------
  # Option 1: Kubernetes TLS with cert-manager (Recommended for production)
  #   - Automatic Let's Encrypt certificates
  #   - Requires cert-manager installed in cluster
  #   - Set tls.enabled: true and tls.certManager.enabled: true
  #
  # Option 2: Manual TLS certificate
  #   - Create your own kubernetes secret with certificate
  #   - Set tls.enabled: true and provide tls.secretName
  tls:
    enabled: false  # Set to true if using Option 1 or 2
    secretName: "aurora-tls"  # Secret name for manual certificates (Option 2)
    
    # Automatic certificate management with cert-manager (Option 1)
    certManager:
      enabled: false  # Set to true to use cert-manager with Let's Encrypt
      issuer: "letsencrypt-prod"  # ClusterIssuer name (must be created separately)
      email: ""  # Email for Let's Encrypt notifications
  
  hosts:
    frontend: "aurora.example.com"
    api: "api.aurora.example.com"
    ws: "ws.aurora.example.com"

# ------------------------------------------------------------------------------
# Vault Auto-Unseal Configuration (Optional)
# ------------------------------------------------------------------------------
# By default, Vault uses Shamir seals (manual unsealing after pod restarts).
# For production, configure auto-unseal with cloud KMS.
# See docs/KMS_SETUP.md for detailed setup guides.
#
# WARNING: If KMS key is deleted, Vault data is permanently unrecoverable.
vault:
  seal:
    # Options: "shamir" (default), "gcpckms"
    type: "shamir"
    
    # GCP Cloud KMS Configuration
    # See docs/KMS_GCP.md for setup instructions
    # gcpckms:
    #   project: "your-project-id"
    #   region: "us-central1"
    #   key_ring: "vault-keyring"
    #   crypto_key: "vault-unseal-key"
    #   # For on-prem: credentials: "/vault/gcp/credentials.json"
